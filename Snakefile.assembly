import shutil
import glob
import os

configfile : config.get("configfile")

# Collect samples. They need to be stored in data/
SAMPLES,R, = glob_wildcards("data/{id}_{r}.fastq.gz")
SAMPLES = set(SAMPLES)
R = set(R)

onsuccess:
    # delete files
    if  (config["remove_temp"]):
        print("Removing temporary files")
        try:
            shutil.rmtree ("tmp")
        except:
            pass
        try:
            shutil.rmtree ("data")
        except:
            pass
        try:
            shutil.rmtree ("log")
        except:
            pass
        try:
            dirs = glob.glob ("multiqc_report*")
            for dir in dirs:
                shutil.rmtree (dir)
        except:
            pass
        try:
            dirs = glob.glob ("stats/multiqc_report*")
            for dir in dirs:
                shutil.rmtree (dir)
        except:
            pass
        try:
            shutil.rmtree ("ref")
        except:
            pass
    try:
        os.mkdir("results")
    except:
        pass
    for dir in ["stats", "scaffolds"]:
        shutil.move(dir, "results/"+dir)
    print("Workflow finished!")
    return
 
onerror:
    print("Workflow finished with errors")
    os._exit(13)


rule all:
    input:
        "stats/MultiQC_report.html",
        "stats/ResFinder.tsv",
        "stats/MLST.tsv",
        "stats/CoverageStatistics_summary.tsv",
        expand ("scaffolds/{sample}.fna", sample=SAMPLES)

rule fastqc:
    input:
        "data/{sample}_R1.fastq.gz"
    output:
        "tmp/{sample}_R1_fastqc.html",
        temp = "data/{sample}_R1.fastq"
    conda:
        "envs/fastqc.yaml"
    shell:
        "zcat {input} >> {output.temp} "
        "&& fastqc {output.temp} -o tmp"

rule trim:
    input:
        "data/{sample}_{r}.fastq.gz"
    output:
        "tmp/{sample}_{r}.fastq"
    conda:
        "envs/seqtk.yaml"
    params:
       	p = config["seqtk"]["params"]
    shell: 
       "seqtk trimfq {params.p} {input} > {output}"  

rule spades:
    input: 
        R1="tmp/{sample}_R1.fastq",
        R2="tmp/{sample}_R2.fastq"
    output:
        "tmp/assembly/{sample}/scaffolds.fasta"
    conda:
	"envs/spades.yaml"
    params:
        spadesparams = config["SPAdes"]["params"],
        kmer = config["SPAdes"]["krange"],
        cov = config["mincov"],
        outfolder = "tmp/assembly/{sample}"
    shell:
        "spades.py -1 {input.R1} -2 {input.R2} -o {params.outfolder} -k {params.kmer} --cov-cutoff {params.cov} {params.spadesparams}"


rule rename:
    input:
        "tmp/assembly/{sample}/scaffolds.fasta"
    output:
        "scaffolds/{sample}.fna"
    conda:
	"envs/seqtk.yaml"
    params:
        minlen = config["minlen"],
        versiontag = "{sample}_"+config["virtual_environment"]["name"]
    shell:
        "seqtk seq -L {params.minlen} {input} | sed  s/NODE/{params.versiontag}/g > {output}"

      
rule mlst:
    input:
        expand("scaffolds/{sample}.fna", sample=SAMPLES)
    output:
        "stats/MLST.tsv"
    conda:
	"envs/mlst.yaml"
    params:
        mlst = config["mlst"]["params"]
    shell:
        "mlst {params.mlst} {input} > {output}"

rule quast:
    input:
        expand("scaffolds/{sample}.fna", sample=SAMPLES)      
    output:
        html = "tmp/report.html",
        html2 = "stats/Extra/Assembly_report.html"
    conda:
	"envs/quast.yaml"
    params:
        outfolder = "tmp/",
        p = config["QUAST"]["params"]
    shell:
        "quast {params.p} -o {params.outfolder} {input}"
        "&& cp {output.html} {output.html2} " 

rule resfinder:
    input:
        expand("scaffolds/{sample}.fna", sample=SAMPLES) 
    output:
        "stats/ResFinder.tsv"
    conda:
	"envs/abricate.yaml"
    params:
        p = config["abricate"]["params"]
    shell:
        "abricate {params.p} {input} > {output}" 
        "&& sed -i 's/scaffolds\///g' {output}"

rule map:
    input:
        ref = "scaffolds/{sample}.fna",
        in_R1 = "tmp/{sample}_R1.fastq",
        in_R2 = "tmp/{sample}_R2.fastq"
    output:
        covstats_detail = "tmp/CoverageStatistics_{sample}_scaffolds.txt",
        covstats = "stats/Extra/CoverageStatistics_{sample}.txt"
    conda:
	"envs/bbmap.yaml"
    shell:
        "bbmap.sh in={input.in_R1} in2={input.in_R2} ref={input.ref} covstats={output.covstats_detail} >> {output.covstats} 2>&1 " 

rule sum:
    input:
        expand("stats/Extra/CoverageStatistics_{sample}.txt", sample=SAMPLES)
    output:
        "stats/CoverageStatistics_summary.tsv"
    shell:
        "grep 'Average coverage' {input} | sed 's@CoverageStatistics\_@@g' | sed 's@\:Average coverage\:@@g' | sed 's@stats@@g' | sed 's@\\\@@g'| sed 's@\.txt@@g' >> {output}"


rule multiqc:
    input:
        expand("tmp/{sample}_R1_fastqc.html", sample=SAMPLES),
        "tmp/report.html",
        expand("stats/Extra/CoverageStatistics_{sample}.txt", sample=SAMPLES)
    output:
        "stats/MultiQC_report.html"
    conda:
	"envs/multiqc.yaml"
    shell:
        "multiqc tmp/ -n {output}"
